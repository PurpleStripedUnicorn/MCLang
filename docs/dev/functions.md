
# Function generation implementation

Unlike in C, within a function another function can be called that appears later in the script. Also, functions can accept constant parameters, which means a new Minecraft function is created for every instance calling the function with a different value for the constant parameter.

## Function manager

All MCLang functions are kept track of by the function manager, which is a part of the bytecode manager. Functions are registered as pointers to function parse nodes.

## Bytecode function stack

Bytecode functions are generated by the bytecode manager and are kept on a stack to keep track of calls to for example if-statement blocks, which each get their own function.

Aside from the bytecode function stack the bytecode manager also keeps track of all of the functions that have been removed from the bytecode function stack so these functions can then be converted to Minecraft commands later.

## Generation steps

Below all of the steps that are executed to generate functions are listed.

### Step 1: Function registration

All MCLang functions are registered, by adding a pointer to the function node to the function manager.

### Step 2: First function generation

For each function with return type `void` and no parameters the bytecode is generated. During generation calls to ungenerated functions may be encountered. These functions will add an entry in a table which informs that this function still needs to generate with certain constant values inserted, if it hasn't already. When adding this entry a bytecode function name will be reserved so the bytecode for the call can be generated.

### Step 3: Looped function generation

Now for each function that still has in the table mentioned earlier, entries of functions with inserted constant values that need to be generated, the bytecode is generated in the same way as in Step 2.

Then while generating these functions calls may again need functions that have not been generated yet. Again a table entry is added to the MCLang function. Then Step 3 is repeated until there are no more functions left that need to be generated with some constant values, or until a maximum number of loopings has been reached.